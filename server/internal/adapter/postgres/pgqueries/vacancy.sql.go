// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vacancy.sql

package pgqueries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createVacancy = `-- name: CreateVacancy :exec
INSERT INTO vacancies (
    id,
    company_id,
    title,
    description,
    contacts,
    requirements,
    responsibilities,
    conditions,
    employment,
    schedule,
    experience,
    education,
    location,
    is_active,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16
)
`

type CreateVacancyParams struct {
	ID               uuid.UUID
	CompanyID        uuid.UUID
	Title            string
	Description      string
	Contacts         string
	Requirements     string
	Responsibilities string
	Conditions       string
	Employment       string
	Schedule         string
	Experience       string
	Education        string
	Location         string
	IsActive         bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) CreateVacancy(ctx context.Context, arg CreateVacancyParams) error {
	_, err := q.db.Exec(ctx, createVacancy,
		arg.ID,
		arg.CompanyID,
		arg.Title,
		arg.Description,
		arg.Contacts,
		arg.Requirements,
		arg.Responsibilities,
		arg.Conditions,
		arg.Employment,
		arg.Schedule,
		arg.Experience,
		arg.Education,
		arg.Location,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getVacancyByID = `-- name: GetVacancyByID :one
SELECT
    id,
    company_id,
    title,
    description,
    contacts,
    requirements,
    responsibilities,
    conditions,
    employment,
    schedule,
    experience,
    education,
    location,
    is_active,
    created_at,
    updated_at
FROM vacancies
WHERE id = $1
`

func (q *Queries) GetVacancyByID(ctx context.Context, id uuid.UUID) (Vacancy, error) {
	row := q.db.QueryRow(ctx, getVacancyByID, id)
	var i Vacancy
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Contacts,
		&i.Requirements,
		&i.Responsibilities,
		&i.Conditions,
		&i.Employment,
		&i.Schedule,
		&i.Experience,
		&i.Education,
		&i.Location,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveVacancies = `-- name: ListActiveVacancies :many
SELECT
    id,
    company_id,
    title,
    description,
    contacts,
    requirements,
    responsibilities,
    conditions,
    employment,
    schedule,
    experience,
    education,
    location,
    is_active,
    created_at,
    updated_at
FROM vacancies
WHERE is_active = TRUE
ORDER BY created_at DESC
`

func (q *Queries) ListActiveVacancies(ctx context.Context) ([]Vacancy, error) {
	rows, err := q.db.Query(ctx, listActiveVacancies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vacancy
	for rows.Next() {
		var i Vacancy
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Title,
			&i.Description,
			&i.Contacts,
			&i.Requirements,
			&i.Responsibilities,
			&i.Conditions,
			&i.Employment,
			&i.Schedule,
			&i.Experience,
			&i.Education,
			&i.Location,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVacanciesByCompany = `-- name: ListVacanciesByCompany :many
SELECT
    id,
    company_id,
    title,
    description,
    contacts,
    requirements,
    responsibilities,
    conditions,
    employment,
    schedule,
    experience,
    education,
    location,
    is_active,
    created_at,
    updated_at
FROM vacancies
WHERE company_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListVacanciesByCompany(ctx context.Context, companyID uuid.UUID) ([]Vacancy, error) {
	rows, err := q.db.Query(ctx, listVacanciesByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vacancy
	for rows.Next() {
		var i Vacancy
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Title,
			&i.Description,
			&i.Contacts,
			&i.Requirements,
			&i.Responsibilities,
			&i.Conditions,
			&i.Employment,
			&i.Schedule,
			&i.Experience,
			&i.Education,
			&i.Location,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVacancy = `-- name: UpdateVacancy :exec
UPDATE vacancies
SET
    company_id = $1,
    title = $2,
    description = $3,
    contacts = $4,
    requirements = $5,
    responsibilities = $6,
    conditions = $7,
    employment = $8,
    schedule = $9,
    experience = $10,
    education = $11,
    location = $12,
    is_active = $13,
    created_at = $14,
    updated_at = $15
WHERE id = $16
`

type UpdateVacancyParams struct {
	CompanyID        uuid.UUID
	Title            string
	Description      string
	Contacts         string
	Requirements     string
	Responsibilities string
	Conditions       string
	Employment       string
	Schedule         string
	Experience       string
	Education        string
	Location         string
	IsActive         bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
	ID               uuid.UUID
}

func (q *Queries) UpdateVacancy(ctx context.Context, arg UpdateVacancyParams) error {
	_, err := q.db.Exec(ctx, updateVacancy,
		arg.CompanyID,
		arg.Title,
		arg.Description,
		arg.Contacts,
		arg.Requirements,
		arg.Responsibilities,
		arg.Conditions,
		arg.Employment,
		arg.Schedule,
		arg.Experience,
		arg.Education,
		arg.Location,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
